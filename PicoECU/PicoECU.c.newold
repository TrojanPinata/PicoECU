#include <stdio.h>
#include <math.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "hardware/dma.h"
#include "hardware/timer.h"
#include "hardware/clocks.h"
#include "hardware/adc.h"
#include "ssd1306.h"

#define I2C_PORT    i2c0
#define I2C_SDA     0
#define I2C_SCL     1

#define INJECTOR_PIN    21
#define HALL_PIN        20 
#define ADC_MAP_PIN     27 
#define ADC_KNOB_PIN    26

#define ADC_KNOB_CHANNEL    0
#define ADC_MAP_CHANNEL     1 
#define NUM_CHANNELS        2
#define DMA_BUFFER_SIZE     256   // multiple of NUM_CHANNELS
#define SAMPLES_PER_CHANNEL (DMA_BUFFER_SIZE / NUM_CHANNELS)

#define HALL_THRESH     2500
#define HYSTERESIS      200
#define COLD_RATIO      1.3f
#define INTAKE_THRESH   600
#define INJ_DUR_MAX     5000
#define INJ_DUR_MIN     500
#define CYCLE_DELAY     10
#define MIN_CYCLE       300

volatile uint32_t rpm = 0;
volatile uint32_t rpm_max = 0;
volatile uint16_t map = 0;
volatile float afr_knob = 1.0f;
volatile float injector_us = 0;
absolute_time_t last_cycle_time;
volatile bool prev_state = false;
int dma_chan;
bool adc_buf_ready = false;

ssd1306_t disp;
uint16_t adc_dma_buffer[DMA_BUFFER_SIZE];

// prototypes
void prep_injector();
void injector_pulse(float pulse_us);
void display_info();
void dma_irq_handler();
void hall_effect_sensor_callback(uint gpio, uint32_t events);
void process_adc_dma_data();

// fire injector
void injector_pulse(float pulse_us) {
    gpio_put(INJECTOR_PIN, 1);
    sleep_us((int)pulse_us);
    gpio_put(INJECTOR_PIN, 0);
}

// display sensor info on oled
void display_info() {
    char display_buffer[32];
    ssd1306_clear(&disp);

    snprintf(display_buffer, sizeof(display_buffer), "RPM: %4u", rpm);
    ssd1306_draw_string(&disp, 0, 0, 1, display_buffer);

    snprintf(display_buffer, sizeof(display_buffer), "MAP: %u", map);
    ssd1306_draw_string(&disp, 0, 16, 1, display_buffer);

    snprintf(display_buffer, sizeof(display_buffer), "Injector PW: %.2fus", injector_us);
    ssd1306_draw_string(&disp, 0, 28, 1, display_buffer);

    snprintf(display_buffer, sizeof(display_buffer), "AFR_KNOB: %.4f", afr_knob);
    ssd1306_draw_string(&disp, 0, 40, 1, display_buffer);

    ssd1306_show(&disp);
}

void prep_injector() {
    bool intake = (map < INTAKE_THRESH);

    if (intake) {
        float fuel_modifier = 1.0f; // simplified (no temp correction)
        fuel_modifier *= afr_knob;

        float base_pulse_us = 1000 + (700 - map) * 2;
        injector_us = base_pulse_us * fuel_modifier;

        if (injector_us > INJ_DUR_MAX) {
            injector_us = INJ_DUR_MAX;
        } else if (injector_us < INJ_DUR_MIN) {
            injector_us = INJ_DUR_MIN;
        }

        injector_pulse(injector_us);
    } 
}

void hall_effect_sensor_callback(uint gpio, uint32_t events) {
    static absolute_time_t last_time;
    absolute_time_t now = get_absolute_time();
    uint64_t dt = absolute_time_diff_us(last_time, now);
    if (dt > MIN_CYCLE) {
        rpm = 60000000 / dt;
        if (rpm > rpm_max) rpm_max = rpm;
        last_time = now;
        prep_injector();
    }
}

void process_adc_dma_data() {
    uint32_t knob_sum = 0;
    uint32_t map_sum  = 0;
    uint32_t knob_count = 0, map_count = 0;

    for (int i = 0; i < DMA_BUFFER_SIZE; i++) {
        uint16_t sample  = adc_dma_buffer[i] & 0x0FFF; 
        uint8_t channel  = (adc_dma_buffer[i] >> 12) & 0xF;

        switch (channel) {
            case ADC_KNOB_CHANNEL: knob_sum += sample; knob_count++; break;
            case ADC_MAP_CHANNEL:  map_sum  += sample; map_count++;  break;
        }
    }

    uint16_t knob_raw_avg = knob_count ? (knob_sum / knob_count) : 0;
    uint16_t map_raw_avg  = map_count  ? (map_sum  / map_count)  : 0;

    map = map_raw_avg;
    afr_knob = (knob_raw_avg / 4095.0f) * 2.0f;
}

void dma_irq_handler() {
    dma_hw->ints0 = 1u << dma_chan; 
    adc_buf_ready = true;
}

int main() {
    stdio_init_all();
    sleep_ms(1000);
    printf("starting...\n");

    adc_init();
    adc_gpio_init(ADC_KNOB_PIN);
    adc_gpio_init(ADC_MAP_PIN);
    adc_set_round_robin((1 << ADC_KNOB_CHANNEL) | (1 << ADC_MAP_CHANNEL));
    adc_fifo_setup(
        true,   // enable FIFO
        true,   // enable DMA/DREQ
        1,      // DREQ threshold
        false,  // no error bits
        true    // enable channel tag
    );
    adc_set_clkdiv(480);
    adc_fifo_drain();
    adc_run(true);

    dma_chan = dma_claim_unused_channel(true);
    dma_channel_config cfg = dma_channel_get_default_config(dma_chan);
    channel_config_set_transfer_data_size(&cfg, DMA_SIZE_16);
    channel_config_set_read_increment(&cfg, false); 
    channel_config_set_write_increment(&cfg, true); 
    channel_config_set_dreq(&cfg, DREQ_ADC);

    dma_channel_configure(
        dma_chan,
        &cfg,
        adc_dma_buffer,  
        &adc_hw->fifo,   
        DMA_BUFFER_SIZE, 
        true             
    );

    dma_channel_set_irq0_enabled(dma_chan, true);
    irq_set_exclusive_handler(DMA_IRQ_0, dma_irq_handler);
    irq_set_enabled(DMA_IRQ_0, true);

    printf("dma configured...\n");

    gpio_init(HALL_PIN);
    gpio_set_dir(HALL_PIN, GPIO_IN);
    gpio_set_irq_enabled_with_callback(HALL_PIN, GPIO_IRQ_EDGE_FALL, true, hall_effect_sensor_callback);

    gpio_init(INJECTOR_PIN);
    gpio_set_dir(INJECTOR_PIN, GPIO_OUT);
    gpio_put(INJECTOR_PIN, 0);

    i2c_init(I2C_PORT, 400*1000);
    gpio_set_function(I2C_SDA, GPIO_FUNC_I2C);
    gpio_set_function(I2C_SCL, GPIO_FUNC_I2C);
    gpio_pull_up(I2C_SDA);
    gpio_pull_up(I2C_SCL);

    printf("pins setup...\n");

    for (int addr = 0; addr < 128; addr++) {
        if (!i2c_write_blocking(i2c0, addr, NULL, 0, true)) {
            printf("Found I2C device at 0x%02X\n", addr);
        }
    }

    disp.external_vcc = false;
    ssd1306_init(&disp, 128, 64, 0x3C, I2C_PORT);
    printf("screen initialized...\n");

    last_cycle_time = get_absolute_time();

    while (true) {
        display_info();
        if (adc_buf_ready) {
            process_adc_dma_data();
            dma_channel_set_write_addr(dma_chan, adc_dma_buffer, false);
            dma_channel_set_trans_count(dma_chan, DMA_BUFFER_SIZE, true);
            adc_buf_ready = false;
        }
        sleep_ms(CYCLE_DELAY); 
    }

    return 0;
}
